#!/bin/bash

# Production Deployment Script with SSL (Certbot)

set -e # Exit on any error

# --- Configuration ---
LETSENCRYPT_EMAIL="your-email@example.com" # !!! REPLACE THIS !!!
DOMAIN_NAME="classroom.set4.me"
DOCKER_COMPOSE_FILE="docker/docker-compose.simple.yml"
# Flag file to indicate that initial certificates have been obtained (created in the script's directory)
CERTS_OBTAINED_FLAG=".certs_obtained_flag_$(echo $DOMAIN_NAME | sed 's/\./_/g')"


# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_status() {    echo -e "${BLUE}[INFO]${NC} $1"; }
print_success() {   echo -e "${GREEN}[SUCCESS]${NC} $1"; }
print_warning() {   echo -e "${YELLOW}[WARNING]${NC} $1"; }
print_error() {     echo -e "${RED}[ERROR]${NC} $1"; exit 1; }

# --- Main Script ---
print_status "üöÄ Starting Production Deployment with SSL for $DOMAIN_NAME..."

# Step 1: Clean up previous Docker instances (optional, be careful with data)
# print_status "Step 1: Cleaning up previous Docker setup (if any)..."
# docker-compose -f "$DOCKER_COMPOSE_FILE" down --remove-orphans --volumes || true # This will remove data volumes!
# docker system prune -f || true
# print_success "Cleanup completed."

# Step 2: Build frontend (if not already built and available to Nginx)
print_status "Step 2: Building frontend..."
if [ -d "Frontend" ]; then
    print_status "Building frontend using Docker..."
    docker run --rm \
        -v "$(pwd)/Frontend:/app" \
        -w /app \
        node:18-alpine \
        sh -c "npm install && npm run build"
    
    if [ -d "Frontend/dist" ]; then
        print_success "Frontend built successfully."
    else
        print_error "Frontend build failed - dist folder not found."
    fi
else
    print_error "Frontend directory not found!"
fi

# Step 3: Build/Pull Docker images for services
print_status "Step 3: Building/Pulling Docker images for services..."
docker-compose -f "$DOCKER_COMPOSE_FILE" pull # Pull base images like nginx, postgres, certbot
docker-compose -f "$DOCKER_COMPOSE_FILE" build api # Build your API image
print_success "Docker images ready."

# Step 4: Handle SSL Certificate Acquisition with Certbot
if [ ! -f "$CERTS_OBTAINED_FLAG" ]; then
    print_status "Step 4: Initial SSL setup for $DOMAIN_NAME..."

    print_warning "IMPORTANT: Ensure DNS for $DOMAIN_NAME points to this server's IP and ports 80/443 are open."

    print_status "Preparing dummy SSL files for initial Nginx start..."
    # We use the certbot container to create dummy files inside the named volumes
    # This allows Nginx to start even if its config references SSL files that don't exist yet.
    # Certbot will later replace these with real ones.
    # Note: Using weaker crypto for dummy files for speed.
    docker-compose -f "$DOCKER_COMPOSE_FILE" run --rm --entrypoint "\
      sh -c '\
        echo \"Creating dummy certs for $DOMAIN_NAME...\"; \
        mkdir -p /etc/letsencrypt/live/$DOMAIN_NAME && \
        openssl req -x509 -nodes -newkey rsa:1024 -days 1 \
          -keyout /etc/letsencrypt/live/$DOMAIN_NAME/privkey.pem \
          -out /etc/letsencrypt/live/$DOMAIN_NAME/fullchain.pem \
          -subj \"/CN=localhost\" && \
        echo \"Creating dummy options-ssl-nginx.conf...\"; \
        echo \"# SSL options generated by Certbot\" > /etc/letsencrypt/options-ssl-nginx.conf && \
        echo \"ssl_session_cache shared:le_nginx_SSL:10m;\" >> /etc/letsencrypt/options-ssl-nginx.conf && \
        echo \"ssl_session_timeout 1440m;\" >> /etc/letsencrypt/options-ssl-nginx.conf && \
        echo \"ssl_session_tickets off;\" >> /etc/letsencrypt/options-ssl-nginx.conf && \
        echo \"ssl_protocols TLSv1.2 TLSv1.3;\" >> /etc/letsencrypt/options-ssl-nginx.conf && \
        echo \"ssl_prefer_server_ciphers off;\" >> /etc/letsencrypt/options-ssl-nginx.conf && \
        echo \"Creating dummy ssl-dhparams.pem (512 bit, will be replaced by Certbot if needed)...\"; \
        openssl dhparam -out /etc/letsencrypt/ssl-dhparams.pem 512 && \
        echo \"Dummy SSL files created.\" \
      '" certbot

    print_status "Starting Nginx temporarily for Certbot ACME challenge..."
    # Stop Nginx if it's already running from a previous attempt to ensure it starts fresh
    docker-compose -f "$DOCKER_COMPOSE_FILE" stop nginx > /dev/null 2>&1 || true
    docker-compose -f "$DOCKER_COMPOSE_FILE" rm -f nginx > /dev/null 2>&1 || true
    docker-compose -f "$DOCKER_COMPOSE_FILE" up -d nginx

    print_status "Waiting a few seconds for Nginx to be ready..."
    sleep 15

    print_status "Requesting Let's Encrypt certificate for $DOMAIN_NAME..."
    # Use --force-renewal to ensure it overwrites dummy certs and gets real ones.
    # Certbot will also generate proper options-ssl-nginx.conf and ssl-dhparams.pem.
    docker-compose -f "$DOCKER_COMPOSE_FILE" run --rm certbot certonly \
      --webroot -w /var/www/certbot \
      --email "$LETSENCRYPT_EMAIL" \
      -d "$DOMAIN_NAME" \
      --agree-tos \
      --no-eff-email \
      --non-interactive \
      --force-renewal # Important to overwrite dummy certs

    print_success "Certificate acquisition process finished."
    print_status "Creating flag file: $CERTS_OBTAINED_FLAG"
    touch "$CERTS_OBTAINED_FLAG"

    print_status "Restarting Nginx to apply new SSL configuration..."
    docker-compose -f "$DOCKER_COMPOSE_FILE" restart nginx
else
    print_status "Step 4: SSL certificates flag found ($CERTS_OBTAINED_FLAG). Skipping initial acquisition."
    print_status "Nginx will use existing certificates. Certbot container will handle renewals."
fi

# Step 5: Start all services
print_status "Step 5: Bringing up all services..."
docker-compose -f "$DOCKER_COMPOSE_FILE" up -d
print_success "All services should be starting."

# Step 6: Wait and test (optional, adjust as needed)
print_status "Step 6: Waiting for services to stabilize..."
sleep 20 # Adjust as needed

print_status "Testing HTTPS endpoint for $DOMAIN_NAME..."
if curl -ksSf "https://$DOMAIN_NAME" > /dev/null 2>&1; then
    print_success "‚úÖ HTTPS site is accessible at https://$DOMAIN_NAME"
else
    print_warning "‚ùå HTTPS site may not be accessible at https://$DOMAIN_NAME. Check Nginx logs."
    docker-compose -f "$DOCKER_COMPOSE_FILE" logs nginx --tail 20
fi

if curl -ksSf "https://$DOMAIN_NAME/api/health" > /dev/null 2>&1; then
    print_success "‚úÖ API is responding at https://$DOMAIN_NAME/api/health"
else
    print_warning "‚ùå API may not be responding at https://$DOMAIN_NAME/api/health. Check API logs."
    docker-compose -f "$DOCKER_COMPOSE_FILE" logs api --tail 20
fi


# Step 7: Show status
print_status "Step 7: Deployment Summary"
echo ""
echo "=== SERVICES STATUS ==="
docker-compose -f "$DOCKER_COMPOSE_FILE" ps
echo ""
echo "=== NEXT STEPS ==="
echo "1. üåê Open https://$DOMAIN_NAME in your browser"
echo "2. üìù Check logs: docker-compose -f $DOCKER_COMPOSE_FILE logs -f [service_name]"
echo "3. üõë Stop services: docker-compose -f $DOCKER_COMPOSE_FILE down"
echo ""

print_success "üéâ Deployment with SSL completed for $DOMAIN_NAME!"
print_status "Your app should be running at: https://$DOMAIN_NAME"

exit 0